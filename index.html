
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
    <meta name="description" content="">
    <meta name="author" content="">

    <title>PiDeck</title>

    <!-- Bootstrap core CSS -->
    <link href="dist/css/bootstrap.min.css" rel="stylesheet">

    <!-- IE10 viewport hack for Surface/desktop Windows 8 bug -->
    <!-- <link href="../../assets/css/ie10-viewport-bug-workaround.css" rel="stylesheet"> -->

    <!-- Custom styles for this template -->
    <link href="starter-template.css" rel="stylesheet">

    <!-- Just for debugging purposes. Don't actually copy these 2 lines! -->
    <!--[if lt IE 9]><script src="../../assets/js/ie8-responsive-file-warning.js"></script><![endif]-->
    <!-- <script src="../../assets/js/ie-emulation-modes-warning.js"></script> -->

    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
  </head>

  <body>

    <nav class="navbar navbar-inverse navbar-fixed-top">
      <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="#">PiDeck</a>
        </div>
        <div id="navbar" class="collapse navbar-collapse">
          <ul class="nav navbar-nav">
            <li class="active"><a href="#">Home</a></li>
            <li><a href="#intro">Introduction</a></li>
            <li><a href="#obj">Project Objective</a></li>
            <li><a href="#design">Design</a></li>
            <li><a href="#drawings">Hardware Guide</a></li>
            <li><a href="#results">Results</a></li>
          </ul>
        </div><!--/.nav-collapse -->
      </div>
    </nav>

    <div class="container">

      <div class="starter-template">
        <h1>PiDeck</h1>
        <p class="lead">An All-in-One DJ Controller using Raspberry Pi<br>By Christopher Schiff and Justin Green</p>
      </div>

      <hr>
      <div class="center-block">
          <iframe width="640" height="360" src="https://www.youtube.com/embed?v=et91Gea6CPk" frameborder="0" allowfullscreen></iframe>
          <h4 style="text-align:center;">Demonstration Video</h4>
      </div>

      <hr id="intro">

      <div style="text-align:center;">
              <h2>Introduction</h2>
              <p style="text-align: left;padding: 0px 30px;"> At any club, you're likely to find a DJ using a high-tech controller to mix music. The technology behind mixing music has advanced significantly, allowing DJs to manipulate tracks in increasingly entertaining and innovative ways. However, commercial DJ controllers are often expensive and inaccessible, unnecessarily complicating entry into DJing as both a hobby and profession.</p>
      </div>

    <hr id='obj'>

      <div class="row">
          <div class="col-md-4" style="text-align:center;">
            <figure>
              <img class="img-rounded" src="pics/controller.png" alt="Commercial DJ Controller" width="380" height="240">
              <figcaption>Commercial DJ Controller</figcaption>
            </figure>
          </div>
          <div class="col-md-8" style="font-size:18px;">
          <h2>Project Objective:</h2>
          <ul>
              <li>Real-time playback and control of two audio tracks simultaneously </li>
                <li>Controls that are easy to understand and intuitive to use</li>
            <li>Visually appealing board</li>
            <li>Embedded design that doesn't require external software</li>
          </ul>
          </div>
      </div>

    <hr id='design'>

      <div style="text-align:center;">
              <h2>Design</h2>
              <h3>Hardware</h3>
              <figure>
                <img class="img-rounded" src="pics/gpio.png" alt="Commercial DJ Controller" width="640" height="480">
                <figcaption>Hardware Overview</figcaption>
              </figure>
              <br>
              <p style="text-align: left;padding: 0px 30px;">Our hardware for the Raspberry Pi consisted of 4 large push buttons, 4 small push buttons, 2 rotary encoders on top of piTFT. The initial thought was hardware would be simple as the sensors chosen were not very complicated. However, a problem was the management of the sensors with limited GPIO pins on the Raspberry Pi since we needed to use the piTFT to display the song selection. We initially were planning on using an ADC for our linear potentiometers since the Raspberry Pi does not contain a built in ADC. However, we ran out of room so we decide on using an Arduino Uno which has a built-in ADC. All three potentiometers were wired to the Uno. The Arduino had a USB connection that we utilized to send the data from the potentiometers to the Pi. We eventually ran out of space for two small push buttons, but they were powered.

                Given the oddity of the sensors chosen, see references for more information on the individual sensors. 
                
                Here is the breakdown of the GPIO pins used excluding piTFT.
             
                </p>
                <div class="table-responsive">
                  <table class="table table-bordered table-striped">
                      <thead>
                          <tr>
                              <th>Sensor</th>
                              <th>GPIO Pin #('s)</th>
                          </tr>
                      </thead>
                      <tbody>
                          <tr>
                              <td>Large Push Button</td>
                              <td>26</td>
                          </tr>
                          <tr>
                              <td>Large Push Button</td>
                              <td>19</td>
                          </tr>
                          <tr>
                              <td>Large Push Button</td>
                              <td>12</td>
                          </tr>
                          <tr>
                              <td>Large Push Button</td>
                              <td>16</td>
                          </tr>
                          <tr>
                              <td>Small Push Button</td>
                              <td>5</td>
                          </tr>
                          <tr>
                              <td>Small Push Button</td>
                              <td>4</td>
                          </tr>
                          <tr>
                              <td>Rotary Encoder</td>
                              <td>20, 21</td>
                          </tr>
                          <tr>
                              <td>Rotary Encoder</td>
                              <td>13, 6</td>
                          </tr>
                      </tbody>
                  </table>
              </div>
              <p>Figure 3: GPIO Pin Table</p>
              <h3>3D Printed enclosure</h3>
              <p style="text-align: left;padding: 0px 30px;">
                The physical dj board was 3-D printed
                </p>
              <h3>Software</h3>
              <p style="text-align: left;padding: 0px 30px;">
                Pygame.Mixer: 

We ultimately had a big decision between pygame.mixer.sound and pygame.mixer.music. The main trade offs were the features we could implement. With sound, we could add multiple channels which allowed us to have a dual song setup and add in sound effects. With music, we could mutate a single song including play speed and position which would allow features of skipping through the sound and changing the sound speed. We ultimately decided to go with mixer.sound because we believed the additional channels were the most valuable feature of our project.



Overall Logic Overview:

The software component of the project final contained one file final_pt3.py. In the file we handle gathering all the data, playing music and adjusting parameters. Below models the overall logic of the software.

                </p>
                <figure>
                  <img class="img-rounded" src="pics/software.png" alt="Commercial DJ Controller" width="540" height="460">
                  <figcaption>Software Overview</figcaption>
                </figure>
                <br>

                <p style="text-align: left;padding: 0px 30px;">
                  To walk through the logic, the program runs until a quit variable is set, by pressing a piTFT button (GPIO 27). 
                  
                  The program monitors all button presses and rotary encoder changes with callbacks. If an event occurs, the program will run the given callback function.
                  
                  This requires adjustments in the environment. Firstly, the rotary encoders are used to scroll through songs. Their callbacks change an index of the current song hovered. Nextly, the potentiometer data, although not processed from the raspberry pi are used to set the volume variables of the songs. The total volume of a song is composed of 3 variables, one for the associated potentiometer(left or right), one for the center potentiometer(crossfade), and one for an additional constant(overall scaling). Volume is contained in the range [0,1] with 0 meaning silent and 1 meaning max volume. The left potentiometer is used to control the volume of the song chosen on the left side of the screen and the right potentiometer is used to control the volume of the song chosen on the right side of the screen. The crossfade sets the volumes of the two volumes relative to each other. If the slider is all the way to the left, the volume of the left song is maximized and the right is silent and vice versa. Finally, there is an overall scaling constant, which can be increased by pressing the left small button and decreased by the right small button as shown below.
                  
                  
                  
                  Depending on the speakers, the overall scaling of volume may be suited at a higher level than others. 
                  
                  Finally, the large push buttons control song selection and pausing. Each side has two, and the outer button is used for selecting songs and the inner button is used to pause and unpause the song. To know when paused, two state machines were created and are interdependent.
                  </p>
                  <figure>
                    <img class="img-rounded" src="pics/fsm1.png" alt="Commercial DJ Controller" width="340" height="240">
                    <figcaption>Paused State Machine Diagram</figcaption>
                  </figure>
                  <br>
                  <p style="text-align: left;padding: 0px 30px;">
                    As demonstrated in the figure, the paused state(initially paused) will transition to unpaused when the pause button is pressed in that state. The other transition occurs when the other state machine is in the playing state and the pause button is pressed. 
                  </p>
                  <figure>
                    <img class="img-rounded" src="pics/fsm2.png" alt="Commercial DJ Controller" width="380" height="240">
                    <figcaption>Playing State Machine Diagram</figcaption>
                  </figure>
                  <br>
                  <p style="text-align: left;padding: 0px 30px;">
                    As demonstrated in the figure, the paused state(initially paused) will transition to unpaused when the pause button is pressed in that state. The other transition occurs when the other state machine is in the playing state and the pause button is pressed. The other state machine is for a song playing. If in the playing state, the song will transition to not playing if the pause state is unpaused and the paused button is pressed. The other transition was more difficult to design because drawing a progress bar of a song(discussed below) had issues with pausing. The two requirements are either a song is selected and unpaused(only occurs before the first song is chosen) or if the paused state machine is in the paused state and the pause button is pressed. An important note for both these state machines is that since there were two songs played, there were two sets of each state machine implemented, one for each song.

                    piTFT buttons were also incorporated. GPIO pins 17,22,23 were used for sound effects which would play on top of the music selected. They included a set DJ introduction, an airhorn sound, and a double scratch sound, although they are customizable. GPIO pin 27 is used to quit the program.
                    
                    Next, the screen is drawn where there are two main features. Firstly, all the names are displayed in a white color excluding the currently highlighted song (the song that the scroll is on) which is yellow. If the scroll changes, the yellow song changes. Secondly, the selected song is displayed below along with a progress bar showing the percentage of the song that is completed. We found the duration of the song and every iteration updated the bar to reflect the current time minus the start time and paused time. From a coding perspective, this was the most difficult part to figure out because our paused state machine was limited initially. We had to tweak our transitions for the unpaused to paused state because of a few issues. The three issues we encountered were when we switched songs, the progress bar wouldn’t reset, when we would pause and then unpause the bar would reset to blank, and when we paused then unpaused the bar would jump to the percentage of (current time - initial start time) / duration.
                    
                    Finally, the data from the potentiometers are received from the arduino (which just uses a filtered analog Read).
                    
                  </p>
                  <p style="text-align: left;padding: 0px 30px;">
                    The songs selected are customizable, as well as the sound effects. However, they are not customizable during the program. To substitute songs, you must add .wav files to the audio_files directory contained in the project. If that is an issue, .mp3 and .mov files work if you run the bash scripts contained in the folder. For visibility purposes, we recommend a max of 8 songs. To customize the sound effects, .wav files must be added in the root of the project and their names must be sound1.wav, sound2.wav and sound3.wav where the number corresponds to the number sound effect from the top piTFT button to the 3rd from top.
                  </p>







      </div>

    <hr id='drawings'>

      <div style="text-align:center;">
              <h2>Hardware Guide</h2>
              <h3>Slide Potentiometer</h3>
              <figure>
                <img class="img-rounded" src="pics/linearpot.png" alt="Commercial DJ Controller" width="380" height="240">
                <figcaption>Slide Potentiometer Pinout</figcaption>
              </figure>
              <br>
              <p style="text-align: left;padding: 0px 30px;">
                Although there is no data sheet given, through much debugging, we discovered a working model and integrated three into our final project.
                
                
                
                
                There are six pins contrary to the three given. Either pair of the left or right 3 pins(1 out, 1 Gnd, 1 Vcc).  With a 10kohm built in the resistor, the sensor handles input voltage values of 3.3V to 5V although 5V is preferred. Through scoping the output values, the peak output of Vin occurs when the slider is all the way toward the side of the Vcc
                
               
                
                The potentiometer needs to use an ADC for useful values with the Raspberry Pi. If using Arduino, just plug the output into an analog pin due to the built in ADC, and call analogRead(pin#) to store the data. Otherwise, here is one example of a common ADC. Although advertised as linear the potentiometer is most definitely exponential. The max value depends on the sensor itself, but generally log10(max) ~ 2.95 with a 5V power. The logarithmic results showed to be very linear. To capture the smallest values of the potentiometer and to prevent errors, when calling log10(value) remember if value = 0.00 then set it to 1 so it won’t cause a log(0) error.</p>
     
     
              <h2>LED Push Buttons</h2>
              <figure>
                <img class="img-rounded" src="pics/button1.png" alt="Push Button Wiring 1" width="240" height="240">
                <figcaption>Push Button Pin Wiring (LED on when pushed) </figcaption>
              </figure>

              <p style="text-align: left;padding: 0px 30px;">
                There are two options to wire up the push buttons depending on a choice of what you want to do with the LED. If you want to turn on the LED when the button is pressed and then turn off the LED when the button is pressed another time this is the wiring needed.
               </p>
               <figure>
                <img class="img-rounded" src="pics/button2.png" alt="Push Button Wiring 2" width="240" height="240">
                <figcaption>Push Button Pin Wiring (LED always on)</figcaption>
              </figure>


              <p style="text-align: left;padding: 0px 30px;">
                If you want to have the LED permanently on and the button to act as a peripheral this is the wiring needed. Luckily enough, the software was not difficult to establish. They are controlled exactly the same as piTFT buttons. One GPIO pin is needed and the setup is as follows. The pin is read as GPIO IN and is needed to be pulled down. (“GPIO.setup(Pin#, GPIO.IN, pull_up_down=GPIO.PUD_DOWN)”). To read the data make sure to read on the rising edge for cleaner reads.</p>
              

              <h2>Rotary Encoders</h2>
              <figure>
                <img class="img-rounded" src="pics/encoder.png" alt="Rotary Encoder" width="240" height="240">
                <figcaption>Rotary Encoder</figcaption>
              </figure>


              <p style="text-align: left;padding: 0px 30px;">
                
               </p>
              </div>

    

    <hr id='results'>

      <div style="text-align:center;">
              <h2>Results</h2>
              <h3>Conclusions</h3>
              <p style="text-align: left;padding: 0px 30px;">Ultimately we put together a final project encompassing all of our goals. Although we were not able to mutate music to speed up or slow down the songs, we encompassed several other features to manipulate music and incorporate entertaining music. Volume control, stop and start control, sound effects, and dual song playback allow many options of customization.

                Our choice of pygame.mixer.sound was crucial in allowing us to play multiple songs at once and add neat sound effects. Drawing to the piTFT was important to give the DJ a clear sense of the progress of the music and the options for choosing songs. The physical board is a reasonable size and can be easily controlled by a single user.
                </p>
              <h3>Future Work</h3>
              <p style="text-align: left;padding: 0px 30px;">If given more work there are four changes we would make to our DJ controller to expand the functionality. Firstly, the design when displayed on the piTFT had delays in the volume sliders which would needed to be adjusted. Secondly we would like to add more peripherals for more control. Below is an example of the updated logic.

                Thirdly, in a different iteration of our DJ controller we would hope to restructure our audio output to allow for a system so we could change the speed and position of the audio files. Finally, encompassing a method to upload songs live to the dj board would allow more flexibility with music than a limited eight songs.
                
                </p>

      </div>

    <hr>

    <div class="row" style="text-align:center;">
          <h2>Work Distribution</h2>
          <div style="text-align:center;">
              <img class="img-rounded" src="pics/deck.png" alt="PiDeck in Lab" style="width:40%;">
          </div>
          <br>
          <div class="col-md-6" style="font-size:16px">
              <img class="img-rounded" src="pics/justin2.png" alt="Justin Green" width="180" height="240">
              <h3>Justin</h3>
              <p class="lead">jtg239@cornell.edu</p>
              <p><ul>
                <li>Sensors Debugger</li>
                  <li>Music Selector</li>
              <li>Feature Planner</li>
              <li>Program Implementer</li>
              <li>Circuit Designer</li>
              <li>Early Riser</li>
            </ul></p>
          </div>
          <div class="col-md-6" style="font-size:16px">
              <img class="img-rounded" src="pics/christopher.jpeg" alt="Christopher Schiff" width="240" height="240">
              <h3>Christopher</h3>
              <p class="lead">cds258@cornell.edu</p>
              <p><ul>
              <li>3D Designer</li>
              <li>Program Implementer</li>
              <li>Circuit Designer</li>
              <li>Late Sleeper</li>
            </ul></p>
          </div>
      </div>

    <hr>
      <div style="font-size:18px">
          <h2>Parts List</h2>
          <ul>
              <li>Raspberry Pi 4 - Provided in Lab</li>
              <li>Capacitive piTFT - Provided in Lab</li>
              <li>2 x Rotary Encoder - Provided in Lab</li>
              <li>Arduino Uno with USB cord - $27.60</li>
              <a href="https://www.amazon.com/dp/B09D7P3RWZ?psc=1&ref=ppx_yo2ov_dt_b_product_details"><li>3 x 10K Ohm Slide Potentiometer (60 mm) - $13.49 for 5</li></a>
              <a href="https://www.amazon.com/dp/B0C38PBG9R?psc=1&ref=ppx_yo2ov_dt_b_product_details"><li>4 x 12mm Momentary Push Button w/ Green LED - $12.66 for 5</li></a>
              <a href="https://www.amazon.com/dp/B0C38PWG2B?psc=1&ref=ppx_yo2ov_dt_b_product_details"><li>4 x 12mm Momentary Push Button w/ Blue LED - $12.66 for 5</li></a>
              <a href="https://www.amazon.com/dp/B08L13JG8M?ref=ppx_yo2ov_dt_b_product_details&th=1"><li>4 x 19mm Momentary Push Button w/ Blue LED- $13.98 for 5</li></a>
              <a href="https://www.amazon.com/dp/B01MRWL6JS?psc=1&ref=ppx_yo2ov_dt_b_product_details"><li>2 x 16mm Rectangular Push Button w/ White LED* - $9.99 for 5</li></a>
              <a href="https://www.amazon.com/dp/B07T5BFC99?psc=1&ref=ppx_yo2ov_dt_b_product_details"><li>1 x LED Rocker Switch* - $8.66 for 4</li></a>
              <li>Resistors and Wires - Provided in lab</li>
              <li>*Included in physical enclosure but unused in project</li>
          </ul>
      </div>
      <hr>
      <div style="font-size:18px">
          <h2>References</h2>
          
          <a href="https://www.pygame.org/wiki/tutorials">Pygame</a><br>
          <a href="https://www.pygame.org/docs/ref/mixer.html">Pygame.Mixer</a><br>
          <a href="https://roboticsbackend.com/raspberry-pi-arduino-serial-communication/">UART Arduino Raspi</a><br>
          <a href="https://learn.adafruit.com/adafruit-2-8-pitft-capacitive-touch/downloads">piTFT</a><br>
          <a href="https://sourceforge.net/p/raspberry-gpio-python/wiki/Home/">R-Pi GPIO Document</a><br>

      </div>

    <hr>

      <div class="row">
              <h2>Code Appendix</h2>
              <h3>RPi Code (final_pt3.py)</h3>
              <pre><code>import os
import pygame
import RPi.GPIO as GPIO
import time
import pigame
from pydub.utils import mediainfo
from pydub import AudioSegment
import serial
import threading

os.putenv('SDL_VIDEODRV', 'fbcon')
os.putenv('SDL_FBDEV', '/dev/fb0')
os.putenv('SDL_MOUSEDRV', 'dummy')
os.putenv('SDL_MOUSEDEV', '/dev/null')
os.putenv('DISPLAY', '')

# Initialize Pygame
pygame.init()
pitft = pigame.PiTft()
size = width, height = 320, 240
screen = pygame.display.set_mode(size)
pygame.display.set_caption('Dual Channel Music Player')
font = pygame.font.Font(None, 20)
font2 = pygame.font.Font(None, 15)
background_color = (30, 30, 30)
text_color = (255, 255, 255)
highlight_color = (255, 200, 0)
outline_color = (255, 255, 0)  # Yellow outline for visibility

#Initialize PauseL
pauseL = False
firstL = True
paused_timeL = 0.0
paused_initL = 0.0
elapsed_timeL = 0.0
#Initialize PauseR
pauseR = False
firstR = True
paused_timeR = 0.0
paused_initR = 0.0
elapsed_timeR = 0.0

# Encoder 1
pin_a1 = 20  # Encoder 1 pin A
pin_b1 = 21  # Encoder 1 pin B
# Encoder 2
pin_a2 = 13  # Encoder 2 pin A
pin_b2 = 6  # Encoder 2 pin B


# Initialize GPIO
GPIO.setmode(GPIO.BCM)
buttons = {'quit': 27, 'sound1': 17, 'sound2': 22, 'sound3': 23, 
'A1' :pin_a1, 'B1': pin_b1, 'A2': pin_a2, 'B2': pin_b2 }

for button in buttons.values():
    GPIO.setup(button, GPIO.IN, pull_up_down=GPIO.PUD_UP)

# Initialize the mixer
pygame.mixer.init(frequency=22050, size=-16, channels=2, buffer=4096)
channels = [pygame.mixer.Channel(0), pygame.mixer.Channel(1), pygame.mixer.Channel(2)]
music_directory = 'audio_files'
songs = sorted([f for f in os.listdir(music_directory) if f.endswith('.wav')])
indexes = [0, 0]  # Indexes for each channel's current selection
currently_playing = [0, 0]
active_list = 0   # Initialize active_list

# Load durations using Pydub
def get_durations(songs, music_directory):
    durations = []
    for song in songs:
        song_path = os.path.join(music_directory, song)
        audio_info = mediainfo(song_path)
        duration = float(audio_info['duration'])
        durations.append(duration)
    return durations

song_durations = get_durations(songs, music_directory)
start_times = [None, None]  # Start times for each song
label_max = 20

def play_song(channel_index, song_index):
    track = pygame.mixer.Sound(os.path.join(music_directory, songs[song_index]))
    channels[channel_index].play(track)
    start_times[channel_index] = time.time()
    currently_playing[channel_index] = song_index

def draw_menu():
    global paused_timeL, firstL, elapsed_timeL, pauseL, paused_initL, paused_timeR, firstR, elapsed_timeR, pauseR, paused_initR
    screen.fill(background_color)
    y_offset = 8
    for i, song in enumerate(songs):
        for j in range(2):  # Assuming two channels
            x_offset = 10 + j * 150
            is_active = indexes[j] == i #and j == active_list
            color = highlight_color if is_active else text_color
            song_label = f'> {song}' if is_active else song
            if len(song_label) > label_max:
                song_label = song_label[:label_max]
            text_surf = font.render(song_label, True, color)
            screen.blit(text_surf, (x_offset, y_offset + i * 20))

    # Draw progress bars with outlines and current song names
    bar_height = 20
    bar_width = 140
    for j in range(2):
        bar_x = 10 + j * 150
        bar_y = y_offset + len(songs) * 20 + 20  # Additional space for song name text
        if channels[j].get_busy() and start_times[j] is not None:
            # Display the current song name
            current_song_name = songs[currently_playing[j]]
            if len(current_song_name) > label_max:
                current_song_name = current_song_name[:label_max]
            song_name_surf = font2.render(current_song_name, True, highlight_color)
            screen.blit(song_name_surf, (bar_x, bar_y - 15))  # Position above the progress bar

            # Calculate and draw the progress bar
            if j == 0:
                if pauseL:
                    if firstL:
                        paused_initL = time.time()
                        firstL = False
                    else:
                        paused_timeL = time.time() - paused_initL
                else:
                    if paused_timeL != 0:
                        firstL = True
                        start_times[j] += paused_timeL
                        paused_timeL, paused_initL = 0,0
                    elapsed_timeL = time.time() - start_times[j]
                # progress = elapsed_timeL / song_durations[j]
            else: 
                if pauseR:
                    if firstR:
                        paused_initR = time.time()
                        firstR = False
                    else:
                        paused_timeR = time.time() - paused_initR
                else:
                    if paused_timeR != 0:
                        firstR = True
                        start_times[j] += paused_timeR
                        paused_timeR, paused_initR = 0,0
                    elapsed_timeR = time.time() - start_times[j]
                # progress = elapsed_timeR / song_durations[j]
            progress = elapsed_timeL / song_durations[j] if j == 0 else elapsed_timeR / song_durations[j]
            bar_length = int(progress * bar_width)
            pygame.draw.rect(screen, highlight_color, (bar_x, bar_y, bar_length, bar_height))
            pygame.draw.rect(screen, outline_color, (bar_x, bar_y, bar_width, bar_height), 2)  # Outline
    
    pygame.display.flip()
    pitft.update()

def handle_quit(channel):
    pygame.quit()
    GPIO.cleanup()
    del(pitft)
    import sys
    sys.exit(0)
    exit()

def handle_select(channel):
    channels[active_list].stop()
    play_song(active_list, indexes[active_list])

def handle_scroll(channel):
    indexes[active_list] = (indexes[active_list] + 1) % len(songs)
    draw_menu()

def scroll_wheel(id, amt):
    #print(f"scroll {id},{amt}")
    global indexes, songs
    indexes[id] = (indexes[id] + amt) % len(songs)
    draw_menu()


def handle_switch(channel):
    global active_list
    active_list = 1 - active_list
    draw_menu()



#GPIO.setup([pin_a1, pin_b1, pin_a2, pin_b2], GPIO.IN, pull_up_down=GPIO.PUD_UP)

# Counters for each encoder
counter1 = 0
last_state1 = None
counter2 = 0
last_state2 = None

#define volume parameters
vol = 1



count0 = 0
count1 = 0

clk0LastState = GPIO.input(pin_a1)
clk1LastState = GPIO.input(pin_a2)

def handle_rotary0():
        global count0, clk0LastState
        clk0State = GPIO.input(pin_a1)
        dt0State = GPIO.input(pin_b1)
        if clk0State != clk0LastState:
                if dt0State != clk0State:
                        count0 += 1
                        scroll_wheel(0,-1)
                else:
                        count0 -= 1
                        scroll_wheel(0,1)
                #print(f"count0: {count0}")
        clk0LastState = clk0State

def handle_rotary1():
        global count1, clk1LastState
        clk1State = GPIO.input(pin_a2)
        dt1State = GPIO.input(pin_b2)
        if clk1State != clk1LastState:
                if dt1State != clk1State:
                        count1 += 1
                        scroll_wheel(1,1)
                else:
                        count1 -= 1
                        scroll_wheel(1,-1)
                #print(f"count1: {count1}")
        clk1LastState = clk1State


# Callback function for Encoder 1
def rotary_callback1():
    #print("rcb1")
    global counter1, last_state1
    state_a = GPIO.input(pin_a1)
    state_b = GPIO.input(pin_b1)
    if state_a and state_b:
        if last_state1 == "CW":
            counter1 -= 1
            scroll_wheel(0,-1)
        elif last_state1 == "CCW":
            counter1 += 1
            scroll_wheel(0,1)
        #print("Encoder 1 Counter: ", counter1)
    elif state_a and not state_b:
        last_state1 = "CW"
    elif not state_a and state_b:
        last_state1 = "CCW"

# Callback function for Encoder 2
def rotary_callback2():
    #print("rcb2")
    global counter2, last_state2
    state_a = GPIO.input(pin_a2)
    state_b = GPIO.input(pin_b2)
    if state_a and state_b:
        if last_state2 == "CW":
            counter2 += 1
            scroll_wheel(1,1)
        elif last_state2 == "CCW":
            counter2 -= 1
            scroll_wheel(1,-1)
       # print("Encoder 2 Counter: ", counter2)
    elif state_a and not state_b:
        last_state2 = "CW"
    elif not state_a and state_b:
        last_state2 = "CCW"

def sound_effect1(channel):
    # Stop any current playback on the new channel
    channels[2].stop()
    # Play the sound effect on the new channel
    sound_effect = pygame.mixer.Sound('/home/pi/final_project/sound1.wav')
    channels[2].play(sound_effect)

def sound_effect2(channel):
    # Stop any current playback on the new channel
    channels[2].stop()
    # Play the sound effect on the new channel
    sound_effect = pygame.mixer.Sound('/home/pi/final_project/sound2.wav')
    channels[2].play(sound_effect)

def sound_effect3(channel):
    # Stop any current playback on the new channel
    channels[2].stop()
    # Play the sound effect on the new channel
    sound_effect = pygame.mixer.Sound('/home/pi/final_project/sound3.wav')
    channels[2].play(sound_effect)


# Attach callbacks
GPIO.add_event_detect(buttons['quit'], GPIO.FALLING, callback=handle_quit, bouncetime=300)
GPIO.add_event_detect(buttons['sound1'], GPIO.FALLING, callback=sound_effect1, bouncetime=300)
GPIO.add_event_detect(buttons['sound2'], GPIO.FALLING, callback=sound_effect2, bouncetime=300)
GPIO.add_event_detect(buttons['sound3'], GPIO.FALLING, callback=sound_effect3, bouncetime=300)
# Add event detection for both encoders
# GPIO.add_event_detect(pin_a1, GPIO.BOTH, callback=rotary_callback1, bouncetime=100)
# GPIO.add_event_detect(pin_b1, GPIO.BOTH, callback=rotary_callback1, bouncetime=100)
# GPIO.add_event_detect(pin_a2, GPIO.BOTH, callback=rotary_callback2, bouncetime=100)
# GPIO.add_event_detect(pin_b2, GPIO.BOTH, callback=rotary_callback2, bouncetime=100)


GPIO.setup(26, GPIO.IN, pull_up_down=GPIO.PUD_DOWN)
GPIO.setup(19, GPIO.IN, pull_up_down=GPIO.PUD_DOWN)
GPIO.setup(12, GPIO.IN, pull_up_down=GPIO.PUD_DOWN)
GPIO.setup(16, GPIO.IN, pull_up_down=GPIO.PUD_DOWN)

GPIO.setup(4, GPIO.IN, pull_up_down=GPIO.PUD_DOWN)
GPIO.setup(5, GPIO.IN, pull_up_down=GPIO.PUD_DOWN)

ch1_pause = False
ch2_pause = False
ch1_play = False
ch2_play = False

def left_left_cb(channel):
    # CH1 Select
    #print("CH1 Select")
    global ch1_play, ch1_pause
    if not ch1_pause:
      channels[0].stop()
      play_song(0, indexes[0])
      ch1_play = True

def left_right_cb(channel):
    # CH1  Pause
    #print("CH1 Pause")
    global ch1_pause, pauseL, ch1_play
    if(ch1_pause):
        channels[0].unpause()
        ch1_pause = False
        ch1_play = True
        pauseL = False
    else:
        channels[0].pause()
        if (ch1_play):
          pauseL = True
          ch1_pause = True
          ch1_play = False
        
def right_left_cb(channel):
    # CH2 Pause
    #print("CH2 Pause")
    global ch2_pause, pauseR, ch2_play
    if(ch2_pause):
        channels[1].unpause()
        ch2_pause = False
        ch2_play = True
        pauseR = False
    else:
        channels[1].pause()
        if ch2_play:
          ch2_pause = True
          pauseR = True
          ch2_play = False

def right_right_cb(channel):
    # CH2 Select
    #print("CH2 Select")
    global ch2_play, ch2_pause
    if not ch2_pause:
      channels[1].stop()
      play_song(1, indexes[1])
      ch2_play = True

GPIO.add_event_detect(26, GPIO.RISING, callback=left_right_cb, bouncetime=200)
GPIO.add_event_detect(19, GPIO.RISING, callback=left_left_cb, bouncetime=200)
GPIO.add_event_detect(12, GPIO.RISING, callback=right_right_cb, bouncetime=200)
GPIO.add_event_detect(16, GPIO.RISING, callback=right_left_cb, bouncetime=200)

def inc_volume(channel):
  global vol
  vol *= 1.1

def dec_volume(channel):
  global vol
  vol /= 1.1


GPIO.add_event_detect(5, GPIO.RISING, callback=inc_volume, bouncetime=200)
GPIO.add_event_detect(4, GPIO.RISING, callback=dec_volume, bouncetime=200)

def map_value(x, original_max=29.35, target_max=1):
    return x / original_max
    
ser = serial.Serial('/dev/ttyACM0', 9600, timeout=1)
ser.reset_input_buffer()


data = {'pot#l' : 0.5, 'pot#r': 0.5, 'pot#c': 0.5}
def update_volumes():
    # Calculate the effective volume for each channel
    # Channel 1 (Left) fades in as pot#c goes from 0 to 1
    # Channel 0 (Right) fades out as pot#c goes from 0 to 1
    left_volume = vol * data['pot#l'] * data['pot#c']  # Increases as pot#c goes from 0 to 1
    right_volume = vol * data['pot#r'] * (1 - data['pot#c'])  # Decreases as pot#c goes from 0 to 1

    # Set the volumes
    channels[1].set_volume(left_volume)
    channels[0].set_volume(right_volume)




def rotary_encoder_thread():
    global counter1, last_state1, counter2, last_state2

    global count0, clk0LastState, count1, clk1LastState
    while True:
        handle_rotary0()
        handle_rotary1()
        # rotary_callback1()
        # rotary_callback2()
        #thread.sleep(0.01)


# Create and start the rotary encoder thread
rotary_thread = threading.Thread(target=rotary_encoder_thread)
rotary_thread.daemon = True
rotary_thread.start()


try:
    while True:
       
        
        draw_menu()
        
        if ser.in_waiting > 0:
            line = ser.readline().decode('utf-8', errors='ignore').rstrip()
            if line:
                try:
                    # Split the line by commas and filter out empty strings
                    entries = filter(None, line.split(','))
                    # Loop through each non-empty entry and parse it
                    for entry in entries:
                        # Split the entry into key and value parts
                        key, value = entry.split(':')
                        # Clean up any whitespace and convert value to float
                        key = key.strip()
                        value = float(value.strip())
                        data[key] = map_value(value)
                    # Now you can use the data dictionary for further processing
                  #  print(data)  # Example usage
                    update_volumes()
                except ValueError as e:
                    print(f"Error parsing line: {line}, Error: {e}")
        
       # thread.sleep(0.01)

except:
    print("Caught exception")
    GPIO.cleanup()        
finally:
    GPIO.cleanup()
    del(pitft)


              </code></pre>
      <h3>Arduino Uno Code (potentiometer.ino)</h3>
      <pre><code>
        #define pot1 A0
#define pot2 A1
#define pot3 A2

float val;
String pos;

void setup() {
  pinMode(A0, OUTPUT);
  pinMode(A1, OUTPUT);
  pinMode(A2, OUTPUT);
  Serial.begin(9600);

}

void loop() {
  //Prints the value of ADC
  for (int chan=0; chan<3; chan++) {
    if (chan == 0) {
      val = analogRead(pot1);
      pos = "c";
    }
    else if (chan == 1) {
      val = analogRead(pot2); 
      pos = "l";
    }
    else {
      val = analogRead(pot3);
      pos = "r";
    }
    if (val == 0.00) {
      val = 1;
    }
    val = 10 * log10(val);
    Serial.print("pot#");
    Serial.print(pos);
    Serial.print(": ");
    Serial.print(val);
    Serial.print(",\n");
  }
  
 
  delay(10);
}


</code></pre>
      </div>

    </div><!-- /.container -->




    <!-- Bootstrap core JavaScript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js"></script>
    <script>window.jQuery || document.write('<script src="../../assets/js/vendor/jquery.min.js"><\/script>')</script>
    <script src="dist/js/bootstrap.min.js"></script>
    <!-- IE10 viewport hack for Surface/desktop Windows 8 bug -->
    <!-- <script src="../../assets/js/ie10-viewport-bug-workaround.js"></script> -->
  </body>
</html>
